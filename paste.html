<!DOCTYPE html>
<html>

<!--

# Paste Service On Top Of ClickHouse

## About

This service is developed to demonstrate some features of ClickHouse
like asynchronous INSERTs, direct querying from HTML page, MATERIALIZED and EPHEMERAL columns,
CONSTRAINTS, custom HTTP handlers, quotas and user access control, etc.
in a toy service similar to "pastebin" or "gist".

Features:
- data is instantly saved in ClickHouse after pasting or editing - single page with no "save" button;
- after data is saved or loaded, you see the check mark in the bottom right corner;
- just copy the link from the address bar - it is a permanent link to the data;
- you can edit already saved data but the new link will be created and the old links remain permanent;
- you can host Markdown pages - just add .md to the URL and share it;
- you can host HTML pages - just add .html to the URL and share it;
- browser history is used while editing for easy undo;
- edit history is also saved in the database: after you load the data,
  previous version of the data is available by clicking the "back" button in bottom right corner;

## Motivation

ClickHouse is analytical database, and the usage scenario of this service
is definitely not the most natural for ClickHouse.
Nevertheless, it is always important to test the system in corner cases
and unusual scenarios to find potential flaws and to explore new possibilities.

## Contributing

Please send a pull request to
https://github.com/ClickHouse/ClickHouse/blob/master/utils/paste/paste.html

## Terms Of Use

This service can be used for helping ClickHouse development.
No other usages permitted.

## Warranty

No warranties or conditions of any kind, either express or implied.
The data can be removed or lost at any moment of time.

## Security And Privacy

This service may not provide any security or privacy.

## Cookie Policy

This service does not use cookies.

## Report Abuse

To report abuse, write to feedback@clickhouse.com
DMCA violations should be reported as well.

## Installation

```
CREATE DATABASE paste ENGINE = Replicated('/clickhouse/databases/paste/', '{shard}', '{replica}');

CREATE TABLE paste.data
(
    fingerprint UInt32 DEFAULT reinterpretAsUInt32(unhex(fingerprint_hex)),
    hash UInt128 DEFAULT reinterpretAsUInt128(unhex(hash_hex)),
    prev_fingerprint UInt32 DEFAULT reinterpretAsUInt32(unhex(prev_fingerprint_hex)),
    prev_hash UInt128 DEFAULT reinterpretAsUInt128(unhex(prev_hash_hex)),
    content String,

    size UInt32 MATERIALIZED length(content),
    time DateTime64 MATERIALIZED now64(),
    query_id String MATERIALIZED queryID(),

    fingerprint_hex String EPHEMERAL '',
    hash_hex String EPHEMERAL '',
    prev_fingerprint_hex String EPHEMERAL '',
    prev_hash_hex String EPHEMERAL '',

    CONSTRAINT length CHECK length(content) < 10 * 1024 * 1024,
    CONSTRAINT hash_is_correct CHECK sipHash128(content) = reinterpretAsFixedString(hash),
    CONSTRAINT not_uniform_random CHECK length(content) < 10000 OR arrayReduce('entropy', extractAll(content, '.')) < 7,
    CONSTRAINT not_constant CHECK length(content) < 10000 OR arrayReduce('uniqUpTo(1)', extractAll(content, '.')) > 1,

    PRIMARY KEY (fingerprint, hash)
)
ENGINE = ReplicatedMergeTree;

CREATE USER paste IDENTIFIED WITH no_password
DEFAULT DATABASE paste
SETTINGS
    add_http_cors_header = 1,
    async_insert = 1,
    wait_for_async_insert = 0,
    limit = 1,
    offset = 0,
    max_result_rows = 1,
    force_primary_key = 1,
    max_query_size = '10M';

CREATE QUOTA paste
KEYED BY ip_address
FOR RANDOMIZED INTERVAL 1 MINUTE MAX query_selects = 100, query_inserts = 1000, written_bytes = '10M',
FOR RANDOMIZED INTERVAL 1 HOUR MAX query_selects = 1000, query_inserts = 10000, written_bytes = '50M',
FOR RANDOMIZED INTERVAL 1 DAY MAX query_selects = 5000, query_inserts = 50000, written_bytes = '200M'
TO paste;

GRANT SELECT, INSERT ON paste.data TO paste;
```

-->

<head>
    <meta charset="UTF-8">
    <title>Paste</title>
    <style>
        html, body, textarea {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: sans-serif;
        }

        textarea {
            outline: none;
            border: none;
            margin: 0.5em;
            width: calc(100% - 1em);
            height: calc(100% - 1em);
        }

        .status {
            position: absolute;
            right: 1em;
            bottom: 0.5em;
            z-index: 1;
            font-size: 200%;
            font-family: sans-serif;
            display: none;
        }

        #hourglass {
            color: gray;
            animation: spin 2s infinite;
        }

        #check-mark {
            color: green;
        }

        @keyframes spin {
            100% { transform: rotate(360deg); }
        }

        #back {
            cursor: pointer;
            font-weight: bold;
        }

        a:hover {
            color: #00b3ee;
        }

        .markdown {
            margin: 1em;
            width: calc(100% - 2em);
            height: auto;
        }
    </style>
</head>
<body>
<span class="status" id="hourglass">⧗</span>
<span class="status" id="check-mark">✔</span>
<span class="status" id="error">❌</span>
<a class="status" id="back">⎌</a>
<textarea id="data" autofocus></textarea>
<script type="text/javascript">

const clickhouse_url = "https://play.clickhouse.com/?user=paste";

const encoder = new TextEncoder();

function sipHash128(m) {
    function rotl(v, offset, bits) {
        v[offset] = (v[offset] << bits) | (v[offset] >> (64n - bits));
    }

    function compress(v) {
        v[0] += v[1];
        v[2] += v[3];
        rotl(v, 1, 13n);
        rotl(v, 3, 16n);
        v[1] ^= v[0];
        v[3] ^= v[2];
        rotl(v, 0, 32n);
        v[2] += v[1];
        v[0] += v[3];
        rotl(v, 1, 17n);
        rotl(v, 3, 21n);
        v[1] ^= v[2];
        v[3] ^= v[0];
        rotl(v, 2, 32n);
    }

    const view = new DataView(m.buffer);
    let buf = new Uint8Array(new ArrayBuffer(8));
    let v = new BigUint64Array([0x736f6d6570736575n, 0x646f72616e646f6dn, 0x6c7967656e657261n, 0x7465646279746573n]);

    let offset = 0;
    for (; offset < m.length - 7; offset += 8) {
        let word = view.getBigUint64(offset, true);
        v[3] ^= word;
        compress(v);
        compress(v);
        v[0] ^= word;
    }

    buf.set(m.slice(offset));
    buf.fill(0, m.length - offset, 7);
    buf[7] = m.length;

    let word = new DataView(buf.buffer).getBigUint64(0, true);

    v[3] ^= word;
    compress(v);
    compress(v);
    v[0] ^= word;
    v[2] ^= 0xFFn;
    compress(v);
    compress(v);
    compress(v);
    compress(v);

    return ('00000000000000000000000000000000' + ((v[0] ^ v[1]) + ((v[2] ^ v[3]) << 64n)).toString(16)).substr(-32).
        match(/../g).reverse().join('');
}

function getFingerprint(text) {
    return text.match(/\p{L}{4,100}/gu).
        map((elem, idx, arr) => idx + 2 < arr.length ? [elem, arr[idx + 1], arr[idx + 2]] : []).
        filter(elem => elem.length === 3).map(elem => elem.join()).
        filter((elem, idx, arr) => arr.indexOf(elem) === idx).
        map(elem => sipHash128(encoder.encode(elem)).substr(0, 8)).
        reduce((min, curr) => curr < min ? curr : min, 'ffffffff');
}

let curr_fingerprint = '';
let curr_hash = '';
let prev_fingerprint = '';
let prev_hash = '';

let request_num = 0;

let back = document.getElementById('back');
let check = document.getElementById('check-mark');
let error = document.getElementById('error');
let wait = document.getElementById('hourglass');

function hide() {
    back.style.display = 'none';
    check.style.display = 'none';
    error.style.display = 'none';
    wait.style.display = 'none';
}

function show(what) {
    hide();
    what.style.display = 'block';
}

async function load(fingerprint, hash, type) {
    show(wait);

    const response = await fetch(
        clickhouse_url,
        { method: "POST", body: `SELECT content, lower(hex(reinterpretAsFixedString(prev_hash))) AS prev_hash, lower(hex(reinterpretAsFixedString(prev_fingerprint))) AS prev_fingerprint FROM data WHERE fingerprint = reinterpretAsUInt32(unhex('${fingerprint}')) AND hash = reinterpretAsUInt128(unhex('${hash}')) ORDER BY time LIMIT 1 FORMAT JSON` });

    function onError() {
        show(error);
        throw new Error(`Load failed\nHTTP status ${response.status}\nMessage: ${response.body}`);
    }

    if (!response.ok) onError();
    const json = await response.json();
    if (json.rows != 1) onError();

    const result = json.data[0];
    const content = result.content;

    prev_hash = result.prev_hash;
    prev_fingerprint = result.prev_fingerprint;

    curr_hash = hash;
    curr_fingerprint = fingerprint;

    if (type === '.html' || type == '.htm') {
        document.open();
        document.write(content);
        document.close();
    } else if (type === '.md' || type === '.markdown') {
        await loadMarkdownRenderer();
        document.body.className = 'markdown';
        document.body.innerHTML = marked.parse(content);
    } else {
        document.getElementById('data').value = content;

        if (prev_hash == '00000000000000000000000000000000') {
            hide();
        } else {
            show(back);
        }
    }
}

async function save(text) {
    const my_request_num = ++request_num;

    show(wait);

    const response = await fetch(
        clickhouse_url,
        {
            method: "POST",
            body: "INSERT INTO data (fingerprint_hex, hash_hex, prev_fingerprint_hex, prev_hash_hex, content) FORMAT JSONEachRow " + JSON.stringify(
            {
                fingerprint_hex: curr_fingerprint,
                hash_hex: curr_hash,
                prev_fingerprint_hex: prev_fingerprint,
                prev_hash_hex: prev_hash,
                content: text
            })
        });

    if (!response.ok) {
        show(error);
        throw new Error(`Saving failed\nHTTP status ${response.status}`);
    }

    if (my_request_num == request_num) {
        history.pushState(null, null, window.location.pathname.replace(/(\?.+)?$/, `?${curr_fingerprint}/${curr_hash}`));
        show(check);
    }
}

/// Huge JS libraries should be loaded only if needed.
function loadJS(src, integrity) {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        if (integrity) {
            script.crossOrigin = 'anonymous';
            script.integrity = integrity;
        } else {
            console.warn('no integrity for', src)
        }
        script.addEventListener('load', function() { marked.setOptions({ gfm: true, breaks: true }); resolve(true); });
        document.head.appendChild(script);
    });
}

let load_markdown_promise;
function loadMarkdownRenderer() {
    if (load_markdown_promise) { return load_markdown_promise; }

    return loadJS('https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.2/marked.min.js',
        'sha512-hzyXu3u+VDu/7vpPjRKFp9w33Idx7pWWNazPm+aCMRu26yZXFCby1gn1JxevVv3LDwnSbyKrvLo3JNdi4Qx1ww==');
}


document.getElementById('data').addEventListener('input', (event) => {

    prev_fingerprint = curr_fingerprint;
    prev_hash = curr_hash

    const text = document.getElementById('data').value;

    curr_hash = sipHash128(encoder.encode(text));
    curr_fingerprint = getFingerprint(text);

    save(text);
});

back.addEventListener('click', (event) => {
    load(prev_fingerprint, prev_hash);
    history.pushState(null, null, window.location.pathname.replace(/(\?.+)?$/, `?${curr_fingerprint}/${curr_hash}`));
});

function restore() {
    const components = window.location.search.match(/^\?([0-9a-f]{8})\/([0-9a-f]{32})(\.md|\.markdown|\.html?)?/);
    if (components) load(components[1], components[2], components[3]);
}

window.onpopstate = function(event) {
    restore();
};

restore();

</script>
</body>
</html>
